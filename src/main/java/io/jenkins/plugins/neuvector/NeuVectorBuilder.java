package io.jenkins.plugins.neuvector;

import com.google.common.base.Strings;
import hudson.AbortException;
import hudson.EnvVars;
import hudson.Extension;
import hudson.FilePath;
import hudson.Launcher;
import hudson.model.AbstractProject;
import hudson.model.Run;
import hudson.model.TaskListener;
import hudson.tasks.ArtifactArchiver;
import hudson.tasks.Builder;
import hudson.tasks.BuildStepDescriptor;
import hudson.util.FormValidation;
import hudson.util.ListBoxModel;

import java.io.IOException;
import java.io.PrintStream;
import java.util.List;

import jenkins.tasks.SimpleBuildStep;
import net.sf.json.JSONArray;
import net.sf.json.JSONObject;
import net.sf.json.JSONException;
import org.jenkinsci.Symbol;
import org.kohsuke.stapler.DataBoundConstructor;
import org.kohsuke.stapler.StaplerRequest;
import org.kohsuke.stapler.QueryParameter;

import javax.annotation.Nonnull;


public class NeuVectorBuilder extends Builder implements SimpleBuildStep {

    private static final String REGISTRY_DROPDOWN_DEFAULT = "Please select a registry:";
    private final String repository;
    private final String tag;
    private final String numberOfHighSeverityToFail;
    private final String numberOfMediumSeverityToFail;
    private final String nameOfVulnerabilityToFailOne;
    private final String nameOfVulnerabilityToFailTwo;
    private final String nameOfVulnerabilityToFailThree;
    private final String nameOfVulnerabilityToFailFour;
    private final String registrySelection;

    @DataBoundConstructor
    public NeuVectorBuilder(String repository, String tag, String numberOfHighSeverityToFail,
                            String numberOfMediumSeverityToFail, String nameOfVulnerabilityToFailOne,
                            String nameOfVulnerabilityToFailTwo, String nameOfVulnerabilityToFailThree,
                            String nameOfVulnerabilityToFailFour, String registrySelection) {
        this.repository = repository.trim();
        this.tag = tag.trim();
        this.numberOfHighSeverityToFail = numberOfHighSeverityToFail.trim();
        this.numberOfMediumSeverityToFail = numberOfMediumSeverityToFail.trim();
        this.nameOfVulnerabilityToFailOne = nameOfVulnerabilityToFailOne.trim();
        this.nameOfVulnerabilityToFailTwo = nameOfVulnerabilityToFailTwo.trim();
        this.nameOfVulnerabilityToFailThree = nameOfVulnerabilityToFailThree.trim();
        this.nameOfVulnerabilityToFailFour = nameOfVulnerabilityToFailFour.trim();
        this.registrySelection = registrySelection;
    }

    public String getRepository() {
        return repository;
    }

    public String getTag() {
        return tag;
    }

    public String getNumberOfHighSeverityToFail() {
        return numberOfHighSeverityToFail;
    }

    public String getNumberOfMediumSeverityToFail() {
        return numberOfMediumSeverityToFail;
    }

    public String getNameOfVulnerabilityToFailOne() {
        return nameOfVulnerabilityToFailOne;
    }

    public String getNameOfVulnerabilityToFailTwo() {
        return nameOfVulnerabilityToFailTwo;
    }

    public String getNameOfVulnerabilityToFailThree() {
        return nameOfVulnerabilityToFailThree;
    }

    public String getNameOfVulnerabilityToFailFour() {
        return nameOfVulnerabilityToFailFour;
    }

    public String getRegistrySelection() {
        return registrySelection;
    }

    @Override
    public void perform(@Nonnull Run<?, ?> run, @Nonnull FilePath workspace, @Nonnull Launcher launcher, @Nonnull TaskListener listener)
            throws IOException, InterruptedException {
        DescriptorImpl globalConfig = getDescriptor();

        String artifactName = "NeuVectorReport_" + run.getParent().getDisplayName() + "_" + run.getNumber();
        FilePath workspaceFP = new FilePath(workspace, artifactName);
        PrintStream printStream = new PrintStream(workspaceFP.write(), false, "UTF-8");

        try {
            Log logger = new Log(printStream, listener);

            String controllerIP = globalConfig.getControllerIP().trim();
            int controllerPort = Integer.parseInt(globalConfig.getControllerPort().trim());
            String user = globalConfig.getUser().trim();
            String password = globalConfig.getPassword().trim();
            int timeout = globalConfig.getTimeout();
            List<Registry> registries = globalConfig.getRegistries(); //registries can be null if nothing in global config

            if (controllerIP.isEmpty() || user.isEmpty() || password.isEmpty()) {
                throw new AbortException("Missing global configuration for NeuVector.");
            }

            final EnvVars env = run.getEnvironment(listener);
            String currentRepository = env.expand(repository);
            String currentTag = env.expand(tag);

            logger.log();
            logger.log("*************************************************************");

            boolean isLocal = true;
            Registry selectRegistry = null;

            if (Strings.isNullOrEmpty(registrySelection) || registrySelection.equalsIgnoreCase(REGISTRY_DROPDOWN_DEFAULT)) {
                // Case: no registry selected in task.
                throw new AbortException("Please select a registry or choose Local.");
            } else if (registrySelection.equalsIgnoreCase("Local")) {
                // Case: Local.
                logger.log("Local case.");
            } else {
                // Case: pre-defined registry selected. Maybe deleted already.
                if (registries == null) {
                    // Case: registry deleted in global
                    throw new AbortException("Registry " + registrySelection + " in current project is missing or deleted in global configuration.");
                } else {
                    boolean found = false;
                    for (Registry registry : registries) {
                        if (registry.getNickname().isEmpty() || registry.getRegUrl().isEmpty()) {
                            throw new AbortException("Registry nickname and URL cannot be empty");
                        }
                        if (registry.getNickname().equalsIgnoreCase(registrySelection)) {
                            // Case: registry found in global
                            found = true;
                            isLocal = false;
                            selectRegistry = registry;
                            logger.log("Registry: " + registrySelection);
                            logger.log("Registry URL: " + selectRegistry.getRegUrl());
                            logger.log("Registry Username: " + selectRegistry.getRegUsername());
                            break;
                        }
                    }
                    if (!found) {
                        // Case: registry deleted in global
                        throw new AbortException("Registry " + registrySelection + " in current project is missing or deleted in global configuration.");
                    }
                }
            }

            logger.log("Repository: " + currentRepository);
            logger.log("Tag: " + currentTag);

            Config config = new Config(controllerIP, controllerPort, user, password, timeout, isLocal, selectRegistry,
                    currentRepository, currentTag, numberOfHighSeverityToFail, numberOfMediumSeverityToFail,
                    nameOfVulnerabilityToFailOne, nameOfVulnerabilityToFailTwo, nameOfVulnerabilityToFailThree,
                    nameOfVulnerabilityToFailFour);
            NeuVectorWorker worker = new NeuVectorWorker(logger, config);
            worker.scan();
        } finally {
            printStream.close();
            ArtifactArchiver artifactArchiver = new ArtifactArchiver(artifactName);
            artifactArchiver.perform(run, workspace, launcher, listener);
            run.addAction(new NeuVectorAction(run, artifactName));
            workspaceFP.delete();
        }
    }

    @Override
    public DescriptorImpl getDescriptor() {
        return (DescriptorImpl) super.getDescriptor();
    }

    @Symbol("neuvector")
    @Extension
    public static final class DescriptorImpl extends BuildStepDescriptor<Builder> {
        /**
         * To persist global configuration information, simply store it in a field and
         * call save().
         */
        private String controllerIP;
        private String controllerPort;
        private String user;
        private String password;
        private int timeout;
        private List<Registry> registries;

        public void setControllerIP(String controllerIP) {
            this.controllerIP = controllerIP;
        }

        public void setControllerPort(String controllerPort) {
            this.controllerPort = controllerPort;
        }

        public void setUser(String user) {
            this.user = user;
        }

        public void setPassword(String password) {
            this.password = password;
        }

        public void setTimeout(int timeout) {
            this.timeout = timeout;
        }

        public void setRegistries(List<Registry> registries) {
            this.registries = registries;
        }

        public String getControllerIP() {
            return controllerIP;
        }

        public String getControllerPort() {
            return controllerPort;
        }

        public String getUser() {
            return user;
        }

        public String getPassword() {
            return password;
        }

        public int getTimeout() {
            return timeout;
        }

        public List<Registry> getRegistries() {
            return registries;
        }

        public DescriptorImpl() {
            load();
        }

        public ListBoxModel doFillRegistrySelectionItems() {
            ListBoxModel items = new ListBoxModel();
            items.add(REGISTRY_DROPDOWN_DEFAULT);
            items.add("Local");
            if (registries != null) {
                for (Registry reg : registries) {
                    items.add(reg.getNickname());
                }
            }
            return items;
        }

        public FormValidation doCheckRegistrySelection(@QueryParameter String value) {
            if (Strings.isNullOrEmpty(value) || value.equalsIgnoreCase(REGISTRY_DROPDOWN_DEFAULT)) {
                return FormValidation.error(Messages.NeuVectorBuilder_DescriptorImpl_errors_registrySelection());
            }
            return FormValidation.ok();
        }

        public FormValidation doCheckControllerIP(@QueryParameter String value) {
            if (Strings.isNullOrEmpty(value) || value.trim().isEmpty() || value.trim().matches("^(http|https)://.*$")) {
                return FormValidation.error(Messages.NeuVectorBuilder_DescriptorImpl_errors_controllerIP());
            }
            return FormValidation.ok();
        }

        public FormValidation doCheckControllerPort(@QueryParameter String value) {
            try {
                if (Integer.parseInt(value.trim()) < 0) {
                    return FormValidation.error(Messages.NeuVectorBuilder_DescriptorImpl_errors_controllerPort());
                }
                return FormValidation.ok();
            } catch (NumberFormatException e) {
                return FormValidation.error(Messages.NeuVectorBuilder_DescriptorImpl_errors_controllerPort());
            }
        }

        public FormValidation doCheckUser(@QueryParameter String value) {
            if (Strings.isNullOrEmpty(value) || value.trim().isEmpty()) {
                return FormValidation.error(Messages.NeuVectorBuilder_DescriptorImpl_errors_user());
            }
            return FormValidation.ok();
        }

        public FormValidation doCheckPassword(@QueryParameter String value) {
            if (Strings.isNullOrEmpty(value) || value.trim().isEmpty()) {
                return FormValidation.error(Messages.NeuVectorBuilder_DescriptorImpl_errors_password());
            }
            return FormValidation.ok();
        }

        public FormValidation doCheckTimeout(@QueryParameter String value) {
            try {
                if (Integer.parseInt(value) < 0) {
                    return FormValidation.error(Messages.NeuVectorBuilder_DescriptorImpl_errors_timeout());
                }
                return FormValidation.ok();
            } catch (NumberFormatException e) {
                return FormValidation.error(Messages.NeuVectorBuilder_DescriptorImpl_errors_timeout());
            }
        }

        public FormValidation doTestConnection(@QueryParameter("controllerIP") String controllerIP,
                                               @QueryParameter("controllerPort") String controllerPort,
                                               @QueryParameter("user") String user,
                                               @QueryParameter("password") String password) {
            int port;
            try {
                port = Integer.parseInt(controllerPort.trim());
            } catch (NumberFormatException e) {
                return FormValidation.error(Messages.NeuVectorBuilder_DescriptorImpl_errors_controllerPort());
            }
            Config config = new Config(controllerIP, port, user, password, 0, false, null,
                    null, null, null, null,
                    null, null, null,
                    null);
            NeuVectorWorker worker = new NeuVectorWorker(null, config);
            try {
                worker.testConnection();
                return FormValidation.ok("Connection Success");
            } catch (IOException e) {
                return FormValidation.error("Connection error: " + e.getMessage());
            }
        }

        @Override
        public boolean isApplicable(Class<? extends AbstractProject> aClass) {
            return true;
        }

        @Override
        public String getDisplayName() {
            return Messages.NeuVectorBuilder_DescriptorImpl_DisplayName();
        }

        @Override
        public boolean configure(StaplerRequest req, JSONObject formData) throws FormException {
            try {
                JSONObject registriesJsonObj = formData.getJSONObject("registries");
                if (registriesJsonObj == null || registriesJsonObj.isEmpty()) {
                    registries = null;
                }
            } catch (JSONException e) {
                JSONArray registriesJsonArray = formData.getJSONArray("registries");
                if (registriesJsonArray == null || registriesJsonArray.isEmpty()) {
                    registries = null;
                }
            }
            req.bindJSON(this, formData);
            save();
            return true;
        }
    }
}